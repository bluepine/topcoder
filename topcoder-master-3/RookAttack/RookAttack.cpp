#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

bool board[300][300];
int row_match[300];
int col_match[300];
int from[300];

class RookAttack {
public:
    int howMany(int rows, int cols, vector <string> cutouts) {
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                board[i][j] = true;
        for (int k = 0; k < (int)cutouts.size(); k++) {
            for (int p1 = 0, p2; p1 < (int)cutouts[k].size(); p1 = p2+1) {
                p2 = cutouts[k].find_first_of(',', p1);
                if (p2 == -1) p2 = cutouts[k].size();
                if (p2-p1 > 0) {
                    istringstream is(cutouts[k].substr(p1, p2-p1));
                    int r, c;
                    is >> r >> c;
                    board[r][c] = false;
                }
            }
        }

        //for (int i = 0; i < rows; i++) {
        //    for (int j = 0; j < cols; j++)
        //        cout << board[i][j] << " ";
        //    cout << endl;
        //}

        for (int i = 0; i < rows; i++)
            row_match[i] = -1;
        for (int j = 0; j < cols; j++)
            col_match[j] = -1;

        int res = 0;
        for (int i = 0; i < rows; i++)
            res += bfs(i, rows, cols);
        return res;
    }

    int bfs(int src, int rows, int cols) {
        for (int i = 0; i < rows; i++)
            from[i] = -1;
        from[src] = src;
        queue<int> q;
        q.push(src);
        bool found = false;
        int where = -1, match = -1;
        while (!q.empty() && !found) {
            where = q.front(); q.pop(); 
            //cout << "where:" << where << endl;
            for (match = 0; match < cols; match++) {
                if (!board[where][match]) continue;
                int next = col_match[match];
                if (where == next) continue;
                if (next == -1) {
                    found = true;
                    break;
                }
                if (from[next] == -1) {
                    q.push(next);
                    from[next] = where;
                    //cout << "push:" << next << endl;
                }
            }
        }
        //cout << "from:" << endl;
        //for (int i = 0; i < rows; i++)
        //    cout << from[i] << " ";
        //cout << endl;

        if (!found) return 0;
        while (from[where] != where) {
            int tmp = row_match[where];
            row_match[where] = match;
            col_match[match] = where;
            where = from[where];
            match = tmp;
        }

        row_match[where] = match;
        col_match[match] = where;

        //cout << "row_match:" << endl;
        //for (int i = 0; i < rows; i++)
        //    cout << row_match[i] << " ";
        //cout << endl;
        //cout << "col_match:" << endl;
        //for (int j = 0; j < cols; j++)
        //    cout << col_match[j] << " ";
        //cout << endl;

        return 1;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, vector <string> p2, bool hasAnswer, int p3) {
    cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << "{";
    for (int i = 0; int(p2.size()) > i; ++i) {
        if (i > 0) {
            cout << ",";
        }
        cout << "\"" << p2[i] << "\"";
    }
    cout << "}";
    cout << "]" << endl;
    RookAttack *obj;
    int answer;
    obj = new RookAttack();
    clock_t startTime = clock();
    answer = obj->howMany(p0, p1, p2);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer) {
        cout << "Desired answer:" << endl;
        cout << "\t" << p3 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer) {
        res = answer == p3;
    }
    if (!res) {
        cout << "DOESN'T MATCH!!!!" << endl;
    } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
        cout << "FAIL the timeout" << endl;
        res = false;
    } else if (hasAnswer) {
        cout << "Match :-)" << endl;
    } else {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main() {
    bool all_right;
    all_right = true;

    int p0;
    int p1;
    vector <string> p2;
    int p3;

    {
        // ----- test 0 -----
        p0 = 8;
        p1 = 8;
        p2.clear();
        p3 = 8;
        all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        p0 = 2;
        p1 = 2;
        string t2[] = {"0 0","0 1","1 1","1 0"};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 0;
        all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        p0 = 3;
        p1 = 3;
        string t2[] = {"0 0","1 0","1 1","2 0","2 1","2 2"};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 2;
        all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        p0 = 3;
        p1 = 3;
        string t2[] = {"0 0","1 2","2 2"};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 3;
        all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 4 -----
        p0 = 200;
        p1 = 200;
        p2.clear();
        p3 = 200;
        all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 5 -----
        p0 = 15;
        p1 = 25;
        string t2[] = {"0 14,14 19,11 23,4 22,13 4,9 11,9 14,4 19,12 19", "11 23,11 16,4 21,1 16,0 15,5 2,1 23,8 15,0 17,3 11", "2 24,2 9,9 0,13 13,2 16,1 1,11 12,9 1,3 23,12 0", "3 22,5 2,10 9,3 9,11 1,9 16,14 20,4 15,5 14,3 9", "13 19,2 12,14 21,5 8,10 17,8 20,8 24,8 3,11 24", "0 15,9 12,9 15,7 5,1 7,4 15,13 19,13 14,8 19,2 17", "3 16,12 24,9 9,9 13,12 14,3 4,2 8,2 21,10 16,1 24", "3 11,3 0,11 22,11 3,6 9,10 18,12 4,12 23,11 22", "11 23,4 18,13 21,8 0,14 9,9 23,9 21,1 9,5 3,8 12", "2 5,7 1,12 21,12 0,8 24,9 13,1 1,14 16,6 21,2 11", "14 6,13 14,7 15,14 13,6 12,14 12,4 12,1 4,8 2,3 24", "14 7,5 9,4 12,8 20,2 20,7 19,0 20,13 22,5 6,0 4", "0 0,2 2,8 18,7 10,2 12,9 0,1 10,6 6,13 15,9 24,2 7", "3 21,5 10,3 11,2 13,6 10,6 13,4 10,8 10,10 11", "10 17,10 3,12 18,11 11,4 14,12 16,5 20,1 11,8 16", "7 15,8 13,6 3,13 12,2 11,3 0,7 3,5 17,7 8,3 21", "5 10,14 13,5 12,12 0,7 12,13 16,3 7,7 14,13 21", "7 16,9 10,3 3,8 10,14 1,4 17,4 2,2 22,5 20,10 6", "5 24,9 6,3 4,0 0,0 10,4 5,1 5,13 16,2 21,3 24,1 13", "11 17,1 5,14 5,2 1,12 4,12 14,3 16,12 10,12 21", "3 7,3 1,2 14,12 15,9 0,7 1,6 12,10 1,13 18,7 18", "11 18,9 15,9 16,14 7,6 0,1 1,4 16,12 24,9 9,11 7", "6 23,7 4,5 20,11 8,7 17,4 8,13 21,1 18,13 4,6 7", "3 9,12 14,13 11,12 2,12 6,2 8,10 9,4 24,8 12,3 20", "13 3,5 13,12 1,2 10,11 20,11 2,13 1,12 18,4 18", "8 7,13 22,4 2,10 18,4 10,7 22,3 24,2 19,6 21,9 20", "6 6,6 11,2 21,2 3,10 10,0 21,7 7,12 3,1 16,14 10", "3 9,3 23,6 17,1 22,3 19,10 20,5 10,1 7,13 4,4 19", "6 12,2 9,6 13,10 12,3 12,14 13,3 13,2 15,8 18,5 14", "3 3,10 24,12 8,13 8,4 5,2 4,0 21,10 22,6 7,7 1,5 7", "12 18,5 24,7 14,5 19,12 3,14 2,3 13,9 23,10 9,3 7", "2 15,13 2,5 4,14 16,2 13,4 15,13 2,13 24,4 12", "14 2,0 1,12 3,11 13,2 23,14 8,6 3,5 12,3 0,8 6", "13 0,0 21,6 1,2 18,1 16,6 23,14 6,0 16,11 9,1 10", "0 24,2 13,12 4,3 14,5 17,8 13,4 0,5 18,2 7,2 2", "7 21,3 9,9 2,11 17,2 15,13 10,4 3,13 20,8 1,0 11", "9 4,6 18,0 23,3 12,12 24,2 19,12 13,3 10,12 17,4 2", "4 11,6 22,6 14,9 18,14 18,2 4,2 24,1 21,7 3,5 16", "2 6,6 9,5 11,8 15,12 8,6 22,13 1,5 6,2 4,7 3,6 11", "11 16,7 17,9 8,10 9,12 24,14 16,8 24,8 19,14 14", "11 6,1 6,4 2,11 14,10 19,10 6,9 9,2 19,5 10,14 19", "14 5,13 17,2 6,8 0,9 21,5 4,3 5,5 19,0 15,12 2", "10 22,2 23,5 17,10 13,6 14,1 19,2 0,14 8,13 18", "2 11,7 13,9 10,6 7,10 23,5 12,1 16,5 20,9 7,3 17", "0 2,5 2,5 21,2 9,2 24,10 10,10 7,11 2,1 20,12 17", "11 5,8 14,11 2,13 23,1 1,11 1,12 2,12 11,8 11,2 12", "7 0,7 4,5 9,7 10,4 5,7 17,7 18,12 4,14 8,2 8,9 5", "6 23,3 3,11 22,9 3,2 2,9 19,4 9,7 21,8 16,2 1", "2 14,0 21,11 17,2 15,3 15,3 22,1 12,3 13,3 0,6 0", "2 17,12 10,7 17,7 12,7 3,10 7,14 21,8 18,9 16,2 24"};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 14;
        all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    if (all_right) {
        cout << "You're a stud (at least on the example cases)!" << endl;
    } else {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
