// knapsack2.c

#include <stdio.h>

// アイテム数。ここを色々変えて実行時間を調べてみるといいかも。20くらいにするとすごく遅い
#define N 3

// 各アイテムの価値と重さを入れる配列
int values[N];
int weights[N];

// 過去の軌跡を保存するための配列
int path[N];

// 価値の最大値を保存する変数
int max = 0;

// 何個目のパターン化を数える変数。アルゴリズム的には意味はない
int index = 0;


// 再帰を使って、全ての組み合わせを調べるrという関数。このプログラムのメインの部分
// あるアイテムをナップザックに入れる場合は1、そうでない場合は0とする。
// たとえばアイテムが3つの場合、
// 0 0 0
// 0 0 1
// 0 1 0
// 0 1 1
// 1 0 0
// 1 0 1
// 1 1 0
// 1 1 1
// という順番で調べる。
// step という引数は、自分が今何個目の変数について調べているかを表している。
// 再帰は理解しづらい概念だけど、小さい値を入れてみて、処理を一手順ずつ追っていくと理解しやすいかも

int r(int step)
{
  // もしstepが0ならば（最後のアイテムまで調べ終わったら）、
  // 価値と重さを計算する。
  if (step == 0)
    {
      int v = 0, w = 0;
      int i;

      // 価値と重さの計算
      for (i=0; i<N; i++)
	{
	  if (path[i] == 1)
	    {
	      v += values[i];
	      w += weights[i];
	    }
	}

      // もし価値が最高だった場合、そのときの価値と重さを表示する。
      // 今は重さのチェックをしていない。する場合はここのifに追加すると良い
      if (max < v)
	{
	  max = v;
	  printf("value: %d\nweight: %d\n", v, w);
	}

      // 今回の組み合わせを表示する。入れたアイテムは1、入れなかったアイテムは0
      printf("%d: ", index++);
      for (i=0; i<N; i++)
	printf("%d ", path[i]);
      printf("\n");

      return 1;
    }


  step--;

  // 現在のアイテムを入れない場合
  path[N-step-1] = 0;
  r(step);

  // 現在のアイテムを入れる場合
  path[N-step-1] = 1;
  r(step);
}

int main(void)
{
  int i;

  // アイテム数Nに応じて、適当にデータを作る処理
  // とりあえず価値も重さも全て1にしている
  for (i=0; i<N; i++)
    {
      values[i] = 1;
      weights[i] = 1;
    }

  // 再帰関数rのよびだし
  r(N);

  return 0;
}

//  int values[N] = {10, 13, 10, 16, 2, 3};
//  int weights[N] = {3, 5, 4, 7, 2, 4};
